//! # Role Service
//!
//! Handles loading and managing user roles from the database.

use entity::{roles::Entity as RolesEntity, sea_orm_active_enums::RoleScopeType, user_roles::Entity as UserRoleEntity};
use sea_orm::{ActiveModelTrait, ColumnTrait, DatabaseConnection, EntityTrait, QueryFilter, Set};
use tracing::info;
use error::Result;

/// Load roles for a specific user
///
/// Queries the user_roles table for the given user ID, joins with the roles table
/// to get role names, and filters out expired roles.
///
/// # Arguments
///
/// * `db` - Database connection
/// * `user_id` - The user ID to load roles for
///
/// # Returns
///
/// Returns `Ok(Vec<String>)` with the role names, or `Err(AppError)` for database errors.
///
/// # Example
/// ```ignore
/// let roles = get_user_roles(&db, user_id).await?;
/// ```
pub async fn get_user_roles(db: &DatabaseConnection, user_id: &str) -> Result<Vec<String>> {
    use sea_orm::sea_query::Condition;
    use entity::user_roles::Column;

    info!(user_id = %user_id, "Loading user roles from database");

    // Find all active user role assignments for this user
    let now = chrono::Utc::now();
    let active_user_roles = UserRoleEntity::find()
        .filter(Column::UserId.eq(user_id))
        .filter(
            Condition::any()
                .add(Column::ExpiresAt.is_null())
                .add(Column::ExpiresAt.gt(now.naive_utc())),
        )
        .find_also_related(RolesEntity)
        .all(db)
        .await?;

    // Extract role names from the joined results
    let role_names: Vec<String> = active_user_roles
        .into_iter()
        .filter_map(|(_, role): (_, Option<_>)| role.map(|role| role.name.clone()))
        .collect();

    if role_names.is_empty() {
        // For users without explicit roles, return empty vec.
        // The application should handle users without roles appropriately,
        // such as denying access or assigning a default role at the application level.
        // Note: A 'user' role should be seeded in the database for basic user permissions.
        info!(
            user_id = %user_id,
            "User has no roles assigned"
        );
        return Ok(vec![]);
    }

    info!(
        user_id = %user_id,
        roles = ?role_names,
        "Successfully loaded user roles"
    );

    Ok(role_names)
}

/// Assign a role to a user
///
/// # Arguments
///
/// * `db` - Database connection
/// * `user_id` - The user ID to assign role to
/// * `role_slug` - The slug of the role to assign (e.g., "super_admin")
/// * `scope_type` - The scope type for this role assignment (global, team, asset)
/// * `scope_id` - Optional scope ID for scoped roles
/// * `expires_at` - Optional expiration date for temporary role assignments
///
/// # Errors
///
/// Returns an error if:
/// - The role doesn't exist
/// - The user_id is invalid
/// - Database operations fail
pub async fn assign_role_to_user(
    db: &DatabaseConnection,
    user_id: &str,
    role_slug: &str,
    scope_type: RoleScopeType,
    scope_id: Option<&str>,
    expires_at: Option<chrono::DateTime<chrono::Utc>>,
) -> Result<()> {
    // Find the role by slug
    let role = RolesEntity::find()
        .filter(entity::roles::Column::Slug.eq(role_slug))
        .one(db)
        .await?
        .ok_or_else(|| error::AppError::database(format!("Role '{}' not found", role_slug)))?;

    // Create user role assignment (ID will be auto-generated by database)
    let active_model = entity::user_roles::ActiveModel {
        // Don't set id - database will auto-generate using CUID2 default
        user_id: Set(user_id.to_string()),
        role_id: Set(role.id),
        scope_type: Set(scope_type),
        scope_id: Set(scope_id.map(|s| s.to_string())),
        expires_at: Set(expires_at.map(|dt| dt.naive_utc())),
        ..Default::default()
    };

    // Insert into database
    active_model.insert(db).await.map_err(|e| {
        // Check if this is a unique constraint violation (duplicate assignment)
        let error_msg = e.to_string().to_lowercase();
        if error_msg.contains("unique constraint") || error_msg.contains("duplicate") {
            error::AppError::conflict(format!(
                "Role '{}' is already assigned to this user",
                role_slug
            ))
        }
        else {
            error::AppError::database(format!("Failed to assign role to user: {}", e))
        }
    })?;

    info!(
        user_id = %user_id,
        role_name = %role.name,
        "Successfully assigned role to user"
    );

    Ok(())
}

#[cfg(test)]
mod tests {
    use sea_orm::{Database, DatabaseConnection};

    use super::*;

    async fn setup_test_db() -> DatabaseConnection {
        // In a real implementation, you'd set up a test database
        // For now, we'll use an in-memory SQLite for basic testing
        Database::connect("sqlite::memory:")
            .await
            .expect("Failed to connect to test database")
    }

    #[tokio::test]
    async fn test_get_user_roles_fails_without_schema() {
        let db = setup_test_db().await;
        let user_id = cuid2::CuidConstructor::new().with_length(32).create_id();

        // Note: In a real test, you'd set up the database schema and ensure no roles exist
        // For this basic test, we expect it to return empty vec
        let result = get_user_roles(&db, &user_id).await;

        // This will fail in current implementation due to no database setup
        // but demonstrates the expected behavior
        assert!(result.is_err()); // Would be Ok(vec![]) with proper setup
    }

    #[tokio::test]
    async fn test_assign_role_to_user_nonexistent_role() {
        let db = setup_test_db().await;
        let user_id = cuid2::CuidConstructor::new().with_length(32).create_id();
        let scope_type = RoleScopeType::Global;

        let result = assign_role_to_user(&db, &user_id, "nonexistent_role", scope_type, None, None).await;

        // Should fail because role doesn't exist
        assert!(result.is_err());
    }

    // Additional tests would include:
    // - test_assign_role_success
    // - test_get_user_roles_with_existing_roles
    // - test_duplicate_role_assignment
}
