//! # Authentication Handlers
//!
//! HTTP request handlers for authentication endpoints.

use auth::{
    jwt::create_access_token,
    password::{hash_password, validate_password_strength, verify_password},
    roles::{assign_role_to_user, get_user_roles},
    secrecy::ExposeSecret,
};
use entity::{
    user_sessions::Entity as UserSessionsEntity,
    users::{Column, Entity as UsersEntity},
};
use sea_orm::{ActiveModelTrait, ColumnTrait, EntityTrait, PaginatorTrait, QueryFilter, Set};
use chrono::{DateTime, FixedOffset, Utc};
use tracing::{debug, warn};
use axum::{extract::Request, Json};
use validator::Validate;
use error::{AppError, Result};

use crate::{
    dto::auth::{
        AuthSuccessResponse,
        AuthTokens,
        AuthenticatedUser,
        LoginRequest,
        RefreshRequest,
        SetupRequest,
        SuccessResponse,
    },
    refresh_tokens::{generate_refresh_token, revoke_refresh_token, validate_refresh_token},
    AppState,
};

/// Helper function to convert DateTime<Utc> to DateTime<FixedOffset> for UTC timezone
/// FixedOffset::east_opt(0) always returns Some for offset 0, so unwrap is safe here
#[inline]
fn to_utc_tz(utc_time: DateTime<Utc>) -> DateTime<FixedOffset> {
    // Safe: FixedOffset::east_opt(0) always returns Some(0) for UTC timezone
    utc_time.with_timezone(&FixedOffset::east_opt(0).expect("Failed to create UTC timezone offset"))
}

/// Inner handler for setup endpoint
///
/// This function doesn't use State extractor and accepts references to AppState.
/// It's intended to be called by wrapper handlers that use State extractor.
pub async fn setup_handler_inner(state: &AppState, req: SetupRequest) -> Result<Json<AuthSuccessResponse>> {
    // Validate request
    req.validate().map_err(|e| {
        AppError::Validation {
            message: e.to_string(),
        }
    })?;

    // Check if any users exist
    let count_result = UsersEntity::find().count(&state.db).await?;
    let user_exists = count_result > 0;

    if user_exists {
        return Err(AppError::conflict(
            "System has already been configured. Use /login instead.".to_string(),
        ));
    }

    // Validate password strength
    if let Err(errors) = validate_password_strength(&req.password) {
        let messages: Vec<String> = errors.iter().map(|e| e.to_string()).collect();
        return Err(AppError::validation(format!(
            "Password validation failed: {}",
            messages.join(", ")
        )));
    }

    // Hash the password
    let password_secret = auth::secrecy::SecretString::from(req.password.clone());
    let hashed_password = hash_password(&password_secret, None)
        .map_err(|e| AppError::internal(format!("Failed to hash password: {}", e)))?;

    // Create the admin user in the database (ID will be auto-generated by database)
    let name_parts: Vec<&str> = req.display_name.split(' ').collect();
    let first_name = name_parts.first().map(|s| s.to_string());
    let last_name = if name_parts.len() > 1 {
        Some(name_parts[1 ..].join(" "))
    }
    else {
        None
    };

    let admin_user = entity::users::ActiveModel {
        // Don't set id - database will auto-generate using CUID2 default
        email: Set(req.email.clone()),
        username: Set(req.email.clone()), // Use email as username for now
        password_hash: Set(hashed_password.expose_secret().to_string()),
        first_name: Set(first_name),
        last_name: Set(last_name),
        status: Set(entity::sea_orm_active_enums::UserStatus::Active),
        created_at: Set(Utc::now().naive_utc()),
        updated_at: Set(Utc::now().naive_utc()),
        ..Default::default()
    };

    use sea_orm::ActiveModelTrait;
    let created_user = admin_user
        .insert(&state.db)
        .await
        .map_err(|e| AppError::database(format!("Failed to create admin user: {}", e)))?;

    // Assign super_admin role to the user in the database
    use entity::sea_orm_active_enums::RoleScopeType;
    assign_role_to_user(
        &state.db,
        &created_user.id,
        "super_admin",
        RoleScopeType::Global,
        None,
        None,
    )
    .await
    .map_err(|e| AppError::database(format!("Failed to assign super_admin role: {}", e)))?;

    debug!(user_id = %created_user.id, email = %req.email, "Admin user created during setup");

    let user = AuthenticatedUser {
        id:           created_user.id,
        email:        req.email.clone(),
        display_name: req.display_name.clone(),
        roles:        vec!["super_admin".to_string()],
    };

    // Generate refresh token (using secure random generation, not CUID2)
    let refresh_token_str = crate::refresh_tokens::generate_refresh_token();

    // Store the refresh token in database (ID will be auto-generated)
    let _refresh_token = crate::refresh_tokens::create_refresh_token(
        &state.db,
        &user.id,
        &refresh_token_str,
        30 * 24 * 60 * 60, // 30 days in seconds
    )
    .await?;

    let tokens = AuthTokens {
        access_token:  create_access_token(
            &state.jwt_config,
            &user.id,
            &req.email,
            &["super_admin".to_string()],
        )?,
        refresh_token: refresh_token_str,
        expires_in:    state.jwt_config.expiration_seconds,
        token_type:    "Bearer".to_string(),
    };

    Ok(Json(AuthSuccessResponse {
        success: true,
        user,
        tokens: Some(tokens),
    }))
}

/// Maximum failed login attempts before account lockout
const MAX_FAILED_LOGIN_ATTEMPTS: i32 = 5;

/// Account lockout duration in minutes
const LOCKOUT_DURATION_MINUTES: i64 = 15;

/// Inner handler for login endpoint
///
/// This function supports:
/// - Account lockout after multiple failed attempts
/// - MFA challenge when MFA is enabled
/// - Automatic lockout reset on successful login
///
/// This function doesn't use State extractor and accepts references to AppState.
/// It's intended to be called by wrapper handlers that use State extractor.
pub async fn login_handler_inner(
    state: &AppState,
    req: LoginRequest,
    headers: axum::http::HeaderMap,
) -> Result<Json<AuthSuccessResponse>> {
    // Validate request
    req.validate().map_err(|e| {
        AppError::Validation {
            message: e.to_string(),
        }
    })?;

    // Find user by email
    let user_option = UsersEntity::find()
        .filter(Column::Email.eq(req.email.clone()))
        .one(&state.db)
        .await?;

    let user = user_option.ok_or_else(|| AppError::unauthorized("Invalid email or password".to_string()))?;

    // Check account lockout
    if let Some(locked_until) = user.locked_until {
        let now_tz = to_utc_tz(Utc::now());
        if locked_until > now_tz {
            let remaining = (locked_until - now_tz).num_minutes() + 1;
            return Err(AppError::unauthorized(format!(
                "Account is temporarily locked due to too many failed login attempts. Try again in {} minute(s).",
                remaining
            )));
        }
        // Lockout has expired, will reset on successful login
    }

    // Verify password
    let password_secret = auth::secrecy::SecretString::from(req.password);
    let password_valid = verify_password(&password_secret, &user.password_hash).is_ok();

    if !password_valid {
        // Increment failed login attempts
        let new_attempts = user.failed_login_attempts + 1;
        let mut active_model: entity::users::ActiveModel = user.clone().into();
        active_model.failed_login_attempts = Set(new_attempts);

        if new_attempts >= MAX_FAILED_LOGIN_ATTEMPTS {
            let locked_until = Utc::now() + chrono::Duration::minutes(LOCKOUT_DURATION_MINUTES);
            let locked_tz = to_utc_tz(locked_until);
            active_model.locked_until = Set(Some(locked_tz));
            tracing::warn!(
                user_id = %user.id,
                email = %user.email,
                attempts = new_attempts,
                "Account locked after {} failed login attempts",
                MAX_FAILED_LOGIN_ATTEMPTS
            );
        }
        active_model.updated_at = Set(Utc::now().naive_utc());
        if let Err(e) = active_model.update(&state.db).await {
            warn!(user_id = %user.id, error = %e, "Failed to update failed login attempts");
        }

        return Err(AppError::unauthorized(
            "Invalid email or password".to_string(),
        ));
    }

    // Check if user is active
    if user.status != entity::sea_orm_active_enums::UserStatus::Active {
        return Err(AppError::unauthorized("Account is not active".to_string()));
    }

    // Reset failed login attempts and lockout on successful login
    if user.failed_login_attempts > 0 || user.locked_until.is_some() {
        let mut active_model: entity::users::ActiveModel = user.clone().into();
        active_model.failed_login_attempts = Set(0);
        active_model.locked_until = Set(None);
        active_model.updated_at = Set(Utc::now().naive_utc());
        let _ = active_model.update(&state.db).await;
    }

    // Check if global MFA enforcement is enabled
    let require_mfa = crate::settings::is_setting_enabled(state, "require_mfa")
        .await
        .unwrap_or(false);

    // If require_mfa is true and user hasn't set up MFA, return special response
    if require_mfa && !user.mfa_enabled {
        // Issue a short-lived MFA enforcement token
        let mfa_token = create_access_token(
            &crate::JwtConfig {
                secret:             state.jwt_config.secret.clone(),
                expiration_seconds: 300, // 5 minutes for MFA setup
                issuer:             state.jwt_config.issuer.clone(),
                audience:           state.jwt_config.audience.clone(),
            },
            &user.id,
            &user.email,
            &["mfa_required".to_string()],
        )?;

        debug!(user_id = %user.id, email = %req.email, "MFA enforcement required - user must set up MFA");

        // Return a response indicating MFA setup is required
        let user_response = AuthenticatedUser {
            id:           user.id.clone(),
            email:        user.email.clone(),
            display_name: format!(
                "{} {}",
                user.first_name.clone().unwrap_or_default(),
                user.last_name.clone().unwrap_or_default()
            )
            .trim()
            .to_string(),
            roles:        vec!["mfa_required".to_string()],
        };

        // Embed the MFA token as the access token, with no refresh token
        return Ok(Json(AuthSuccessResponse {
            success: false,
            user:    user_response,
            tokens:  Some(AuthTokens {
                access_token:  mfa_token,
                refresh_token: String::new(),
                expires_in:    300,
                token_type:    "MfaRequired".to_string(),
            }),
        }));
    }

    // Check MFA requirement (user has MFA enabled)
    if user.mfa_enabled {
        // Issue a short-lived MFA pending token
        let mfa_token = create_access_token(
            &crate::JwtConfig {
                secret:             state.jwt_config.secret.clone(),
                expiration_seconds: 300, // 5 minutes for MFA verification
                issuer:             state.jwt_config.issuer.clone(),
                audience:           state.jwt_config.audience.clone(),
            },
            &user.id,
            &user.email,
            &["mfa_pending".to_string()],
        )?;

        debug!(user_id = %user.id, email = %req.email, "MFA verification required");

        // Return a response indicating MFA is needed
        // We use AuthSuccessResponse with success=false and no tokens
        // The mfa_token is sent via the user field
        let user_response = AuthenticatedUser {
            id:           user.id.clone(),
            email:        user.email.clone(),
            display_name: format!(
                "{} {}",
                user.first_name.clone().unwrap_or_default(),
                user.last_name.clone().unwrap_or_default()
            )
            .trim()
            .to_string(),
            roles:        vec!["mfa_pending".to_string()],
        };

        // Embed the MFA token as the access token, with no refresh token
        return Ok(Json(AuthSuccessResponse {
            success: false,
            user:    user_response,
            tokens:  Some(AuthTokens {
                access_token:  mfa_token,
                refresh_token: String::new(),
                expires_in:    300,
                token_type:    "MfaPending".to_string(),
            }),
        }));
    }

    // Load user roles from database
    let user_roles = get_user_roles(&state.db, &user.id).await?;

    // Generate JWT tokens
    let user_id = user.id.clone();
    let refresh_token_str = generate_refresh_token();

    // Store the refresh token in database (ID will be auto-generated)
    let refresh_token = crate::refresh_tokens::create_refresh_token(
        &state.db,
        &user.id, // Use the actual UUID from user
        &refresh_token_str,
        30 * 24 * 60 * 60, // 30 days in seconds
    )
    .await?;

    // Extract user agent and IP from headers
    let user_agent = headers
        .get("user-agent")
        .and_then(|h| h.to_str().ok())
        .map(|s| s.to_string());

    let ip_address = headers
        .get("x-forwarded-for")
        .or(headers.get("x-real-ip"))
        .and_then(|h| h.to_str().ok())
        .map(|s| s.to_string());

    // Create user session linked to refresh token (ID will be auto-generated)
    let now = Utc::now();
    let now_fixed = now.with_timezone(&chrono::FixedOffset::east_opt(0).unwrap()); // UTC

    let session_model = entity::user_sessions::ActiveModel {
        // Don't set id - database will auto-generate using CUID2 default
        user_id: Set(user.id.clone()),
        refresh_token_id: Set(refresh_token.id),
        user_agent: Set(user_agent),
        ip_address: Set(ip_address),
        created_at: Set(now_fixed),
        last_used_at: Set(now_fixed),
        revoked_at: Set(None),
        ..Default::default()
    };

    UserSessionsEntity::insert(session_model)
        .exec(&state.db)
        .await
        .map_err(|e| AppError::database(format!("Failed to create user session: {}", e)))?;

    // Update last_login_at
    let mut login_update: entity::users::ActiveModel = user.clone().into();
    login_update.last_login_at = Set(Some(Utc::now().naive_utc()));
    login_update.updated_at = Set(Utc::now().naive_utc());
    if let Err(e) = login_update.update(&state.db).await {
        warn!(user_id = %user_id, error = %e, "Failed to update last_login_at");
    }

    let tokens = AuthTokens {
        access_token:  create_access_token(&state.jwt_config, &user_id, &user.email, &user_roles)?,
        refresh_token: refresh_token_str,
        expires_in:    state.jwt_config.expiration_seconds,
        token_type:    "Bearer".to_string(),
    };

    debug!(user_id = %user_id, email = %req.email, "User logged in successfully");

    let user_response = AuthenticatedUser {
        id:           user_id,
        email:        user.email,
        display_name: format!(
            "{} {}",
            user.first_name.unwrap_or_default(),
            user.last_name.unwrap_or_default()
        )
        .trim()
        .to_string(),
        roles:        user_roles,
    };

    Ok(Json(AuthSuccessResponse {
        success: true,
        user:    user_response,
        tokens:  Some(tokens),
    }))
}

/// Inner handler for logout endpoint
///
/// This function doesn't use State extractor and accepts references to AppState.
/// It's intended to be called by wrapper handlers that use State extractor.
pub async fn logout_handler_inner(state: &AppState, request: Request) -> Result<Json<SuccessResponse>> {
    // Extract the authenticated user from request extensions
    let authenticated_user = request
        .extensions()
        .get::<crate::middleware::auth::AuthenticatedUser>()
        .ok_or_else(|| AppError::unauthorized("No authenticated user found".to_string()))?;

    // Parse the user ID
    let user_id = authenticated_user.id.clone();

    // Revoke all refresh tokens for this user
    if let Err(e) = crate::refresh_tokens::revoke_all_user_tokens(&state.db, &user_id).await {
        // Log the error but don't fail the logout
        tracing::warn!("Failed to revoke refresh tokens on logout: {}", e);
    }

    // Delete all user sessions
    let delete_result = entity::user_sessions::Entity::delete_many()
        .filter(entity::user_sessions::Column::UserId.eq(&user_id))
        .exec(&state.db)
        .await;

    match delete_result {
        Ok(result) => {
            tracing::debug!(user_id = %user_id, deleted_count = result.rows_affected, "Deleted user sessions on logout");
        },
        Err(e) => {
            tracing::warn!("Failed to delete user sessions on logout: {}", e);
        },
    }

    // Extract the access token from the Authorization header to blacklist it
    if let Some(auth_header) = request.headers().get("authorization") &&
        let Ok(auth_str) = auth_header.to_str() &&
        let Some(token) = extract_bearer_token(auth_str)
    {
        // Blacklist the token
        let token_hash = crate::token_blacklist::hash_token_for_blacklist(&token);
        let blacklist = crate::token_blacklist::TokenBlacklist::new(state.redis.clone());

        // Calculate expiration time (we'll use the JWT expiration time)
        let expires_at = Utc::now() + chrono::Duration::seconds(state.jwt_config.expiration_seconds as i64);

        if let Err(e) = blacklist.blacklist_token(&token_hash, expires_at).await {
            // Log the error but don't fail the logout
            tracing::warn!("Failed to blacklist token on logout: {}", e);
        }
    }

    // In a stateless JWT setup, logout is handled client-side by removing the token.
    // For enhanced security, we now also blacklist the token server-side and revoke refresh tokens.

    Ok(Json(SuccessResponse {
        success: true,
        message: "Successfully logged out".to_string(),
    }))
}

/// Extract Bearer token from Authorization header
fn extract_bearer_token(auth_header: &str) -> Option<String> {
    if !auth_header.starts_with("Bearer ") {
        return None;
    }

    let token = auth_header.trim_start_matches("Bearer ").trim();

    if token.is_empty() {
        return None;
    }

    Some(token.to_string())
}

/// Inner handler for refresh endpoint
///
/// This function doesn't use State extractor and accepts references to AppState.
/// It's intended to be called by wrapper handlers that use State extractor.
pub async fn refresh_handler_inner(state: &AppState, req: RefreshRequest) -> Result<Json<AuthSuccessResponse>> {
    // Validate the refresh token and get the associated user ID
    let user_id = validate_refresh_token(&state.db, &req.refresh_token).await?;

    // Find the user by ID
    let user = UsersEntity::find_by_id(user_id)
        .one(&state.db)
        .await?
        .ok_or_else(|| AppError::unauthorized("User associated with refresh token not found".to_string()))?;

    // Check if user is active
    if user.status != entity::sea_orm_active_enums::UserStatus::Active {
        return Err(AppError::unauthorized(
            "User account is not active".to_string(),
        ));
    }

    // Load user roles from database
    let user_roles = get_user_roles(&state.db, &user.id).await?;

    // Generate new access token
    let user_id_str = user.id.clone();
    let access_token = create_access_token(&state.jwt_config, &user_id_str, &user.email, &user_roles)?;

    // Generate new refresh token (token rotation for security) - using secure random generation
    let new_refresh_token = crate::refresh_tokens::generate_refresh_token();

    // Store the new refresh token in database (ID will be auto-generated)
    crate::refresh_tokens::create_refresh_token(
        &state.db,
        &user.id, // Use the actual UUID from user
        &new_refresh_token,
        30 * 24 * 60 * 60, // 30 days in seconds
    )
    .await?;

    // Revoke the old refresh token
    revoke_refresh_token(&state.db, &req.refresh_token).await?;

    // Note: In a production system, you might want to blacklist the old access token here
    // For now, we rely on token rotation and short access token expiration

    // Create tokens response
    let tokens = AuthTokens {
        access_token,
        refresh_token: new_refresh_token,
        expires_in: state.jwt_config.expiration_seconds,
        token_type: "Bearer".to_string(),
    };

    let user_response = AuthenticatedUser {
        id:           user_id_str.clone(),
        email:        user.email,
        display_name: format!(
            "{} {}",
            user.first_name.unwrap_or_default(),
            user.last_name.unwrap_or_default()
        )
        .trim()
        .to_string(),
        roles:        user_roles,
    };

    debug!(user_id = %user_id_str, "Refresh token successfully used");

    Ok(Json(AuthSuccessResponse {
        success: true,
        user:    user_response,
        tokens:  Some(tokens),
    }))
}

#[cfg(test)]
mod tests {
    use entity::sea_orm_active_enums::UserStatus;

    use super::*;

    /// Helper to create a test user model for handlers
    fn make_test_user_model(
        id: &str,
        email: &str,
        mfa_enabled: bool,
        failed_attempts: i32,
        locked_until: Option<chrono::DateTime<chrono::FixedOffset>>,
    ) -> entity::users::Model {
        entity::users::Model {
            id: id.to_string(),
            email: email.to_string(),
            username: email.to_string(),
            password_hash: "hashed".to_string(),
            totp_secret: if mfa_enabled {
                Some("test_secret".to_string())
            }
            else {
                None
            },
            first_name: Some("Test".to_string()),
            last_name: Some("User".to_string()),
            avatar_url: None,
            status: UserStatus::Active,
            email_verified_at: None,
            last_login_at: None,
            created_at: chrono::NaiveDateTime::default(),
            updated_at: chrono::NaiveDateTime::default(),
            deleted_at: None,
            backup_codes: None,
            failed_login_attempts: failed_attempts,
            locked_until,
            mfa_enabled,
        }
    }

    #[test]
    fn test_max_failed_login_attempts_value() {
        assert_eq!(MAX_FAILED_LOGIN_ATTEMPTS, 5);
    }

    #[test]
    fn test_lockout_duration_value() {
        assert_eq!(LOCKOUT_DURATION_MINUTES, 15);
    }

    #[test]
    fn test_lockout_duration_is_reasonable() {
        // Lockout should be between 5 and 60 minutes
        assert!(LOCKOUT_DURATION_MINUTES >= 5);
        assert!(LOCKOUT_DURATION_MINUTES <= 60);
    }

    #[test]
    fn test_max_attempts_is_reasonable() {
        // Should be between 3 and 10
        assert!(MAX_FAILED_LOGIN_ATTEMPTS >= 3);
        assert!(MAX_FAILED_LOGIN_ATTEMPTS <= 10);
    }

    #[test]
    fn test_user_model_with_active_lockout() {
        let future_time = chrono::Utc::now().with_timezone(&chrono::FixedOffset::east_opt(0).unwrap()) +
            chrono::Duration::minutes(10);
        let user = make_test_user_model("usr_lock", "locked@test.com", false, 5, Some(future_time));

        assert_eq!(user.failed_login_attempts, MAX_FAILED_LOGIN_ATTEMPTS);
        assert!(user.locked_until.is_some());
        let locked = user.locked_until.unwrap();
        assert!(locked > chrono::Utc::now().with_timezone(&chrono::FixedOffset::east_opt(0).unwrap()));
    }

    #[test]
    fn test_user_model_with_expired_lockout() {
        let past_time = chrono::Utc::now().with_timezone(&chrono::FixedOffset::east_opt(0).unwrap()) -
            chrono::Duration::minutes(20);
        let user = make_test_user_model(
            "usr_unlocked",
            "unlocked@test.com",
            false,
            5,
            Some(past_time),
        );

        assert!(user.locked_until.is_some());
        let locked = user.locked_until.unwrap();
        assert!(locked < chrono::Utc::now().with_timezone(&chrono::FixedOffset::east_opt(0).unwrap()));
    }

    #[test]
    fn test_user_model_no_lockout() {
        let user = make_test_user_model("usr_free", "free@test.com", false, 0, None);

        assert_eq!(user.failed_login_attempts, 0);
        assert!(user.locked_until.is_none());
    }

    #[test]
    fn test_user_model_mfa_enabled() {
        let user = make_test_user_model("usr_mfa", "mfa@test.com", true, 0, None);

        assert!(user.mfa_enabled);
        assert!(user.totp_secret.is_some());
    }

    #[test]
    fn test_user_model_mfa_disabled() {
        let user = make_test_user_model("usr_nomfa", "nomfa@test.com", false, 0, None);

        assert!(!user.mfa_enabled);
        assert!(user.totp_secret.is_none());
    }

    #[test]
    fn test_setup_request_structure() {
        let req = SetupRequest {
            email:        "admin@example.com".to_string(),
            password:     "strongpassword123".to_string(),
            display_name: "admin".to_string(),
        };
        assert_eq!(req.email, "admin@example.com");
        assert_eq!(req.display_name, "admin");
    }

    #[test]
    fn test_login_request_structure() {
        let req = LoginRequest {
            email:    "user@example.com".to_string(),
            password: "password123".to_string(),
        };
        assert_eq!(req.email, "user@example.com");
    }

    #[test]
    fn test_auth_success_response_structure() {
        let response = AuthSuccessResponse {
            success: true,
            user:    AuthenticatedUser {
                id:           "usr_123".to_string(),
                email:        "test@example.com".to_string(),
                display_name: "Test User".to_string(),
                roles:        vec!["admin".to_string()],
            },
            tokens:  Some(AuthTokens {
                access_token:  "access".to_string(),
                refresh_token: "refresh".to_string(),
                expires_in:    3600,
                token_type:    "Bearer".to_string(),
            }),
        };
        assert!(response.success);
        assert_eq!(response.user.id, "usr_123");
        assert!(response.tokens.is_some());
    }

    #[test]
    fn test_auth_success_response_mfa_pending() {
        let response = AuthSuccessResponse {
            success: false,
            user:    AuthenticatedUser {
                id:           "usr_mfa".to_string(),
                email:        "mfa@example.com".to_string(),
                display_name: "MFA User".to_string(),
                roles:        vec!["mfa_pending".to_string()],
            },
            tokens:  Some(AuthTokens {
                access_token:  "mfa_token".to_string(),
                refresh_token: String::new(),
                expires_in:    300,
                token_type:    "MfaPending".to_string(),
            }),
        };
        // MFA pending: success is false, token_type is MfaPending
        assert!(!response.success);
        let tokens = response.tokens.unwrap();
        assert_eq!(tokens.token_type, "MfaPending");
        assert_eq!(tokens.expires_in, 300);
        assert!(tokens.refresh_token.is_empty());
    }

    #[test]
    fn test_refresh_request_structure() {
        let req = RefreshRequest {
            refresh_token: "some_refresh_token".to_string(),
        };
        assert_eq!(req.refresh_token, "some_refresh_token");
    }

    #[test]
    fn test_display_name_formatting() {
        let user = make_test_user_model("usr_1", "test@test.com", false, 0, None);
        let display_name = format!(
            "{} {}",
            user.first_name.unwrap_or_default(),
            user.last_name.unwrap_or_default()
        )
        .trim()
        .to_string();

        assert_eq!(display_name, "Test User");
    }

    #[test]
    fn test_display_name_no_last_name() {
        let mut user = make_test_user_model("usr_1", "test@test.com", false, 0, None);
        user.last_name = None;
        let display_name = format!(
            "{} {}",
            user.first_name.unwrap_or_default(),
            user.last_name.unwrap_or_default()
        )
        .trim()
        .to_string();

        assert_eq!(display_name, "Test");
    }

    #[test]
    fn test_display_name_no_names() {
        let mut user = make_test_user_model("usr_1", "test@test.com", false, 0, None);
        user.first_name = None;
        user.last_name = None;
        let display_name = format!(
            "{} {}",
            user.first_name.unwrap_or_default(),
            user.last_name.unwrap_or_default()
        )
        .trim()
        .to_string();

        assert!(display_name.is_empty());
    }
}
