//! # Refresh Token Service
//!
//! Handles storage, retrieval, and management of JWT refresh tokens.

use base64::{engine::general_purpose, Engine as _};
use chrono::{DateTime, Utc};
use sea_orm::{prelude::*, Set};
use error::{AppError, Result};

/// Refresh token model for database operations
#[derive(Debug, Clone)]
pub struct RefreshToken {
    /// Database ID (auto-generated by database)
    pub id:         String,
    /// User ID this token belongs to
    pub user_id:    String,
    /// Hashed token value
    pub token_hash: String,
    /// When this token expires
    pub expires_at: DateTime<Utc>,
    /// When this token was revoked (soft delete)
    pub revoked_at: Option<DateTime<Utc>>,
    /// Creation timestamp
    pub created_at: DateTime<Utc>,
    /// Last update timestamp
    pub updated_at: DateTime<Utc>,
}

/// Creates a new refresh token for a user
///
/// # Arguments
///
/// * `db` - Database connection
/// * `user_id` - The user ID
/// * `token_value` - The raw token value to hash and store
/// * `expires_in_seconds` - How long until the token expires
///
/// # Errors
///
/// Returns an error if database operations fail.
pub async fn create_refresh_token(
    db: &sea_orm::DbConn,
    user_id: &str,
    token_value: &str,
    expires_in_seconds: u64,
) -> Result<RefreshToken> {
    // Hash the token using BLAKE3
    let token_hash = blake3::hash(token_value.as_bytes()).to_hex().to_string();

    // Calculate expiration time
    let expires_at = Utc::now() + chrono::Duration::seconds(expires_in_seconds as i64);

    // Create the active model
    // Note: created_at and updated_at are automatically managed by database defaults
    let active_model = entity::refresh_tokens::ActiveModel {
        user_id: Set(user_id.to_string()),
        token_hash: Set(token_hash.clone()),
        expires_at: Set(expires_at.with_timezone(&chrono::FixedOffset::east_opt(0).unwrap())),
        revoked_at: Set(None),
        ..Default::default()
    };

    // Insert into database
    let model = active_model
        .insert(db)
        .await
        .map_err(|e| AppError::database(format!("Failed to create refresh token: {}", e)))?;

    Ok(RefreshToken {
        id: model.id, // Database ID (auto-generated)
        user_id: model.user_id,
        token_hash,
        expires_at,
        revoked_at: None,
        created_at: model.created_at.with_timezone(&Utc),
        updated_at: model.updated_at.with_timezone(&Utc),
    })
}

/// Validates a refresh token and returns the associated user ID
///
/// # Arguments
///
/// * `db` - Database connection
/// * `token_value` - The raw token value to validate
///
/// # Errors
///
/// Returns an error if the token is invalid, expired, or revoked.
pub async fn validate_refresh_token(db: &sea_orm::DbConn, token_value: &str) -> Result<String> {
    // Hash the token to compare with stored hash
    let token_hash = blake3::hash(token_value.as_bytes()).to_hex().to_string();

    // Find the token in the database
    let token_model = entity::refresh_tokens::Entity::find()
        .filter(entity::refresh_tokens::Column::TokenHash.eq(token_hash))
        .filter(entity::refresh_tokens::Column::RevokedAt.is_null())
        .one(db)
        .await
        .map_err(|e| AppError::database(format!("Failed to query refresh token: {}", e)))?
        .ok_or_else(|| AppError::unauthorized("Invalid refresh token".to_string()))?;

    // Check if token is expired
    let now = Utc::now();
    if token_model.expires_at.with_timezone(&Utc) < now {
        return Err(AppError::unauthorized(
            "Refresh token has expired".to_string(),
        ));
    }

    Ok(token_model.user_id)
}

/// Revokes a refresh token (marks as revoked)
///
/// # Arguments
///
/// * `db` - Database connection
/// * `token_value` - The raw token value to revoke
///
/// # Errors
///
/// Returns an error if database operations fail.
pub async fn revoke_refresh_token(db: &sea_orm::DbConn, token_value: &str) -> Result<()> {
    // Hash the token to find it
    let token_hash = blake3::hash(token_value.as_bytes()).to_hex().to_string();

    // Update the token to mark it as revoked
    let update_result = entity::refresh_tokens::Entity::update_many()
        .col_expr(
            entity::refresh_tokens::Column::RevokedAt,
            Expr::value(Some(Utc::now().naive_utc())),
        )
        .col_expr(
            entity::refresh_tokens::Column::UpdatedAt,
            Expr::value(Utc::now().naive_utc()),
        )
        .filter(entity::refresh_tokens::Column::TokenHash.eq(token_hash))
        .exec(db)
        .await
        .map_err(|e| AppError::database(format!("Failed to revoke refresh token: {}", e)))?;

    if update_result.rows_affected == 0 {
        return Err(AppError::unauthorized(
            "Refresh token not found".to_string(),
        ));
    }

    Ok(())
}

/// Revokes all refresh tokens for a user
///
/// # Arguments
///
/// * `db` - Database connection
/// * `user_id` - The user ID whose tokens should be revoked
///
/// # Errors
///
/// Returns an error if database operations fail.
pub async fn revoke_all_user_tokens(db: &sea_orm::DbConn, user_id: &str) -> Result<()> {
    entity::refresh_tokens::Entity::update_many()
        .col_expr(
            entity::refresh_tokens::Column::RevokedAt,
            Expr::value(Some(Utc::now().naive_utc())),
        )
        .col_expr(
            entity::refresh_tokens::Column::UpdatedAt,
            Expr::value(Utc::now().naive_utc()),
        )
        .filter(entity::refresh_tokens::Column::UserId.eq(user_id))
        .filter(entity::refresh_tokens::Column::RevokedAt.is_null())
        .exec(db)
        .await
        .map_err(|e| AppError::database(format!("Failed to revoke user tokens: {}", e)))?;

    Ok(())
}

/// Cleans up expired refresh tokens
///
/// # Arguments
///
/// * `db` - Database connection
///
/// # Errors
///
/// Returns an error if database operations fail.
pub async fn cleanup_expired_tokens(db: &sea_orm::DbConn) -> Result<u64> {
    let now = Utc::now().naive_utc();

    let delete_result = entity::refresh_tokens::Entity::delete_many()
        .filter(entity::refresh_tokens::Column::ExpiresAt.lt(now))
        .exec(db)
        .await
        .map_err(|e| AppError::database(format!("Failed to cleanup expired tokens: {}", e)))?;

    Ok(delete_result.rows_affected)
}

/// Generates a secure random refresh token value
///
/// # Returns
///
/// A URL-safe base64-encoded random string suitable for use as a refresh token.
pub fn generate_refresh_token() -> String {
    // Generate 32 bytes of random data (256 bits)
    let random_bytes = rand::random::<[u8; 32]>();
    // Encode as URL-safe base64
    general_purpose::URL_SAFE_NO_PAD.encode(random_bytes)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_generate_refresh_token() {
        let token1 = generate_refresh_token();
        let token2 = generate_refresh_token();

        // Tokens should be different
        assert_ne!(token1, token2);

        // Token should be URL-safe base64 (no padding, URL-safe chars)
        assert!(token1
            .chars()
            .all(|c| { c.is_alphanumeric() || c == '-' || c == '_' }));

        // Should be 43 characters (32 bytes base64 encoded without padding)
        assert_eq!(token1.len(), 43);
    }

    #[test]
    fn test_generate_refresh_token_multiple_calls() {
        let tokens: Vec<String> = (0 .. 10).map(|_| generate_refresh_token()).collect();

        // All tokens should be unique
        for (i, token1) in tokens.iter().enumerate() {
            for (j, token2) in tokens.iter().enumerate() {
                if i != j {
                    assert_ne!(
                        token1, token2,
                        "Tokens at index {} and {} should be different",
                        i, j
                    );
                }
            }
        }
    }

    #[test]
    fn test_generate_refresh_token_format() {
        let token = generate_refresh_token();

        // Should only contain URL-safe base64 characters
        assert!(token
            .chars()
            .all(|c| c.is_ascii_alphanumeric() || c == '-' || c == '_'));

        // Should not contain padding or other base64 chars
        assert!(!token.contains('='));
        assert!(!token.contains('+'));
        assert!(!token.contains('/'));
    }

    #[test]
    fn test_generate_refresh_token_length() {
        for _ in 0 .. 100 {
            let token = generate_refresh_token();
            // 32 bytes -> 43 chars in URL-safe base64 without padding
            assert_eq!(token.len(), 43, "Token length should always be 43");
        }
    }

    #[tokio::test]
    async fn test_refresh_token_hashing() {
        let token_value = "test-token-value";
        let hash1 = blake3::hash(token_value.as_bytes()).to_hex().to_string();
        let hash2 = blake3::hash(token_value.as_bytes()).to_hex().to_string();

        // Same input should produce same hash
        assert_eq!(hash1, hash2);

        // Hash should be 64 characters (32 bytes hex encoded)
        assert_eq!(hash1.len(), 64);
    }

    #[test]
    fn test_refresh_token_hash_deterministic() {
        let token = "consistent-token-value";
        let hashes: Vec<String> = (0 .. 5)
            .map(|_| blake3::hash(token.as_bytes()).to_hex().to_string())
            .collect();

        // All hashes should be identical
        for hash in hashes.iter().skip(1) {
            assert_eq!(&hashes[0], hash);
        }
    }

    #[test]
    fn test_refresh_token_hash_different_inputs() {
        let token1 = "token-1";
        let token2 = "token-2";

        let hash1 = blake3::hash(token1.as_bytes()).to_hex().to_string();
        let hash2 = blake3::hash(token2.as_bytes()).to_hex().to_string();

        // Different inputs should produce different hashes
        assert_ne!(hash1, hash2);
    }

    #[test]
    fn test_refresh_token_hash_length() {
        let tokens = vec![
            "short",
            "a-much-longer-token-value-for-testing",
            "token-with-special-chars-!@#$%",
            "",
        ];

        for token in tokens {
            let hash = blake3::hash(token.as_bytes()).to_hex().to_string();
            // BLAKE3 always produces 64-char hex strings (32 bytes)
            assert_eq!(hash.len(), 64, "Hash of '{}' should be 64 chars", token);
        }
    }

    #[test]
    fn test_refresh_token_model_structure() {
        let token = RefreshToken {
            id:         "token-id-123".to_string(),
            user_id:    "user-456".to_string(),
            token_hash: "abc123def456".to_string(),
            expires_at: Utc::now(),
            revoked_at: None,
            created_at: Utc::now(),
            updated_at: Utc::now(),
        };

        assert_eq!(token.id, "token-id-123");
        assert_eq!(token.user_id, "user-456");
        assert_eq!(token.token_hash, "abc123def456");
        assert!(token.revoked_at.is_none());
    }

    #[test]
    fn test_refresh_token_model_revoked() {
        let revoked_time = Utc::now();
        let token = RefreshToken {
            id:         "revoked-token".to_string(),
            user_id:    "user-789".to_string(),
            token_hash: "hash789".to_string(),
            expires_at: Utc::now(),
            revoked_at: Some(revoked_time),
            created_at: Utc::now(),
            updated_at: Utc::now(),
        };

        assert!(token.revoked_at.is_some());
        assert_eq!(token.revoked_at.unwrap(), revoked_time);
    }

    #[test]
    fn test_refresh_token_model_clone() {
        let original = RefreshToken {
            id:         "token-clone-test".to_string(),
            user_id:    "user-clone".to_string(),
            token_hash: "hash-clone".to_string(),
            expires_at: Utc::now(),
            revoked_at: None,
            created_at: Utc::now(),
            updated_at: Utc::now(),
        };

        let cloned = original.clone();
        assert_eq!(original.id, cloned.id);
        assert_eq!(original.user_id, cloned.user_id);
        assert_eq!(original.token_hash, cloned.token_hash);
    }

    #[test]
    fn test_refresh_token_model_debug() {
        let token = RefreshToken {
            id:         "debug-token".to_string(),
            user_id:    "debug-user".to_string(),
            token_hash: "debug-hash".to_string(),
            expires_at: Utc::now(),
            revoked_at: None,
            created_at: Utc::now(),
            updated_at: Utc::now(),
        };

        let debug_str = format!("{:?}", token);
        assert!(debug_str.contains("debug-token"));
        assert!(debug_str.contains("debug-user"));
    }

    #[test]
    fn test_base64_encoding_url_safe() {
        let test_bytes = [
            0xff, 0xfe, 0xfd, 0xfc, 0xfb, 0xfa, 0xf9, 0xf8, 0xf7, 0xf6, 0xf5, 0xf4, 0xf3, 0xf2, 0xf1, 0xf0, 0xef, 0xee,
            0xed, 0xec, 0xeb, 0xea, 0xe9, 0xe8, 0xe7, 0xe6, 0xe5, 0xe4, 0xe3, 0xe2, 0xe1, 0xe0,
        ];

        let encoded = general_purpose::URL_SAFE_NO_PAD.encode(&test_bytes);

        // Should use URL-safe alphabet (no + or /)
        assert!(!encoded.contains('+'));
        assert!(!encoded.contains('/'));
        assert!(!encoded.contains('='));

        // Should be decodable
        let decoded = general_purpose::URL_SAFE_NO_PAD.decode(&encoded);
        assert!(decoded.is_ok());
    }

    #[test]
    fn test_refresh_token_entropy() {
        let tokens: Vec<String> = (0 .. 50).map(|_| generate_refresh_token()).collect();

        // All tokens should be unique (no duplicates)
        let mut seen = std::collections::HashSet::new();
        for token in &tokens {
            assert!(
                seen.insert(token.clone()),
                "Duplicate token found: {}",
                token
            );
        }
    }
}
