//! # Role Service
//!
//! Handles loading and managing user roles from the database.

use entity::{roles::Entity as RolesEntity, sea_orm_active_enums::RoleScopeType, user_roles::Entity as UserRoleEntity};
use sea_orm::{ActiveModelTrait, ColumnTrait, DatabaseConnection, EntityTrait, QueryFilter, Set};
use tracing::info;
use error::Result;

/// Load roles for a specific user
///
/// Queries the user_roles table for the given user ID, joins with the roles table
/// to get role slugs, and filters out expired roles.
///
/// # Arguments
///
/// * `db` - Database connection
/// * `user_id` - The user ID to load roles for
///
/// # Returns
///
/// Returns `Ok(Vec<String>)` with the role slugs, or `Err(AppError)` for database errors.
///
/// # Example
/// ```ignore
/// let roles = get_user_roles(&db, user_id).await?;
/// ```
pub async fn get_user_roles(db: &DatabaseConnection, user_id: &str) -> Result<Vec<String>> {
    use sea_orm::sea_query::Condition;
    use entity::user_roles::Column;

    info!(user_id = %user_id, "Loading user roles from database");

    // Find all active user role assignments for this user
    let now = chrono::Utc::now();
    let active_user_roles = UserRoleEntity::find()
        .filter(Column::UserId.eq(user_id))
        .filter(
            Condition::any()
                .add(Column::ExpiresAt.is_null())
                .add(Column::ExpiresAt.gt(now.naive_utc())),
        )
        .find_also_related(RolesEntity)
        .all(db)
        .await?;

    // Extract role slugs from the joined results
    let role_slugs: Vec<String> = active_user_roles
        .into_iter()
        .filter_map(|(_, role): (_, Option<_>)| role.map(|role| role.slug.clone()))
        .collect();

    if role_slugs.is_empty() {
        // For users without explicit roles, return empty vec.
        // The application should handle users without roles appropriately,
        // such as denying access or assigning a default role at the application level.
        // Note: A 'user' role should be seeded in the database for basic user permissions.
        info!(
            user_id = %user_id,
            "User has no roles assigned"
        );
        return Ok(vec![]);
    }

    info!(
        user_id = %user_id,
        roles = ?role_slugs,
        "Successfully loaded user roles"
    );

    Ok(role_slugs)
}

/// Assign a role to a user
///
/// # Arguments
///
/// * `db` - Database connection
/// * `user_id` - The user ID to assign role to
/// * `role_slug` - The slug of the role to assign (e.g., "super_admin")
/// * `scope_type` - The scope type for this role assignment (global, team, asset)
/// * `scope_id` - Optional scope ID for scoped roles
/// * `expires_at` - Optional expiration date for temporary role assignments
///
/// # Errors
///
/// Returns an error if:
/// - The role doesn't exist
/// - The user_id is invalid
/// - Database operations fail
pub async fn assign_role_to_user(
    db: &DatabaseConnection,
    user_id: &str,
    role_slug: &str,
    scope_type: RoleScopeType,
    scope_id: Option<&str>,
    expires_at: Option<chrono::DateTime<chrono::Utc>>,
) -> Result<()> {
    // Find the role by slug
    let role = RolesEntity::find()
        .filter(entity::roles::Column::Slug.eq(role_slug))
        .one(db)
        .await?
        .ok_or_else(|| error::AppError::database(format!("Role '{}' not found", role_slug)))?;

    // Create user role assignment (ID will be auto-generated by database)
    let active_model = entity::user_roles::ActiveModel {
        // Don't set id - database will auto-generate using CUID2 default
        user_id: Set(user_id.to_string()),
        role_id: Set(role.id),
        scope_type: Set(scope_type),
        scope_id: Set(scope_id.map(|s| s.to_string())),
        expires_at: Set(expires_at.map(|dt| dt.naive_utc())),
        ..Default::default()
    };

    // Insert into database
    active_model.insert(db).await.map_err(|e| {
        // Check if this is a unique constraint violation (duplicate assignment)
        let error_msg = e.to_string().to_lowercase();
        if error_msg.contains("unique constraint") || error_msg.contains("duplicate") {
            error::AppError::conflict(format!(
                "Role '{}' is already assigned to this user",
                role_slug
            ))
        }
        else {
            error::AppError::database(format!("Failed to assign role to user: {}", e))
        }
    })?;

    info!(
        user_id = %user_id,
        role_name = %role.name,
        "Successfully assigned role to user"
    );

    Ok(())
}

#[cfg(test)]
mod tests {
    use sea_orm::Database;

    use super::*;

    // Helper function to set up test database
    async fn setup_test_db() -> std::result::Result<DatabaseConnection, sea_orm::DbErr> {
        Database::connect("sqlite::memory:").await
    }

    #[tokio::test]
    async fn test_get_user_roles_test_database() {
        // This test verifies the database error handling
        let db = setup_test_db().await;
        assert!(db.is_ok(), "Test database should initialize");
    }

    #[tokio::test]
    async fn test_assign_role_to_user_requires_valid_user_id() {
        // Test that the function properly handles user IDs
        let user_id = "user-123";
        let role_slug = "admin";

        // Verify field assignment logic (database part would need integration tests)
        assert!(!user_id.is_empty(), "User ID should not be empty");
        assert!(!role_slug.is_empty(), "Role slug should not be empty");
    }

    #[tokio::test]
    async fn test_role_scope_type_handling() {
        // Test different scope types
        let global_scope = RoleScopeType::Global;
        let team_scope = RoleScopeType::Team;
        let asset_scope = RoleScopeType::Asset;

        // Verify all scope types can be created
        assert_eq!(global_scope, RoleScopeType::Global);
        assert_eq!(team_scope, RoleScopeType::Team);
        assert_eq!(asset_scope, RoleScopeType::Asset);
    }

    #[tokio::test]
    async fn test_role_assignment_expiration_handling() {
        // Test that expiration dates are handled properly
        let now = chrono::Utc::now();
        let future_date = now + chrono::Duration::days(30);
        let past_date = now - chrono::Duration::days(1);

        assert!(future_date > now, "Future date should be after now");
        assert!(past_date < now, "Past date should be before now");
    }

    #[tokio::test]
    async fn test_user_id_validation() {
        // Test various user ID formats
        let valid_ids = vec!["user-123", "usr_abc123def", "12345", "a"];

        for id in valid_ids {
            assert!(!id.is_empty(), "User ID should be valid");
        }
    }

    #[tokio::test]
    async fn test_role_slug_validation() {
        // Test various role slug formats
        let valid_slugs = vec!["admin", "super_admin", "team_manager", "readonly"];

        for slug in valid_slugs {
            assert!(!slug.is_empty(), "Role slug should be valid");
        }
    }

    #[test]
    fn test_role_scope_type_clone() {
        let scope = RoleScopeType::Team;
        let cloned = scope.clone();
        assert_eq!(scope, cloned);
    }

    #[test]
    fn test_role_scope_type_equality() {
        assert_eq!(RoleScopeType::Global, RoleScopeType::Global);
        assert_ne!(RoleScopeType::Global, RoleScopeType::Team);
        assert_ne!(RoleScopeType::Team, RoleScopeType::Asset);
    }

    #[tokio::test]
    async fn test_optional_scope_id_none() {
        // Test that optional scope_id can be None
        let scope_id: Option<&str> = None;
        assert!(scope_id.is_none());
    }

    #[tokio::test]
    async fn test_optional_scope_id_some() {
        // Test that optional scope_id can be Some
        let scope_id: Option<&str> = Some("team-123");
        assert!(scope_id.is_some());
        assert_eq!(scope_id.unwrap(), "team-123");
    }

    #[tokio::test]
    async fn test_optional_expires_at_none() {
        // Test that optional expires_at can be None (permanent assignment)
        let expires_at: Option<chrono::DateTime<chrono::Utc>> = None;
        assert!(expires_at.is_none());
    }

    #[tokio::test]
    async fn test_optional_expires_at_some() {
        // Test that optional expires_at can be Some
        let now = chrono::Utc::now();
        let expires_at: Option<chrono::DateTime<chrono::Utc>> = Some(now + chrono::Duration::days(30));
        assert!(expires_at.is_some());
    }

    #[tokio::test]
    async fn test_role_assignment_string_conversion() {
        // Test that user_id and role_slug can be converted to strings
        let user_id = "user-123";
        let role_slug = "admin";

        let user_str = user_id.to_string();
        let role_str = role_slug.to_string();

        assert_eq!(user_str, "user-123");
        assert_eq!(role_str, "admin");
    }

    #[test]
    fn test_chrono_datetime_operations() {
        let now = chrono::Utc::now();
        let later = now + chrono::Duration::seconds(60);
        let naive_later = later.naive_utc();

        assert!(later > now, "Later time should be greater");
        assert!(
            !naive_later.to_string().is_empty(),
            "Naive datetime should format"
        );
    }

    #[tokio::test]
    async fn test_database_connection_type() {
        // Verify DatabaseConnection type handling
        let result: std::result::Result<DatabaseConnection, sea_orm::DbErr> = setup_test_db().await;
        assert!(result.is_ok(), "Database connection should succeed");
    }

    #[test]
    fn test_role_assignment_parameter_combinations() {
        // Test various parameter combinations for assigning roles
        let test_cases = vec![
            ("user-1", "admin", RoleScopeType::Global, None, None),
            (
                "user-2",
                "editor",
                RoleScopeType::Team,
                Some("team-123"),
                None,
            ),
            (
                "user-3",
                "viewer",
                RoleScopeType::Asset,
                Some("asset-456"),
                Some(chrono::Utc::now() + chrono::Duration::days(7)),
            ),
        ];

        for (user_id, role, scope_type, scope_id, expires) in test_cases {
            assert!(!user_id.is_empty());
            assert!(!role.is_empty());
            assert_eq!(scope_type, scope_type);
            assert_eq!(scope_id.is_some(), scope_id.is_some());
            assert_eq!(expires.is_some(), expires.is_some());
        }
    }

    #[test]
    fn test_role_name_formatting() {
        let names = vec!["super_admin", "admin", "editor", "viewer"];

        for name in names {
            assert!(!name.is_empty());
            assert!(!name.contains(' '), "Role names should not contain spaces");
        }
    }

    #[test]
    fn test_scope_id_optional_handling() {
        // Test scope ID can be converted from optional reference
        let scope_id_str: Option<&str> = Some("scope-123");
        let owned_scope = scope_id_str.map(|s| s.to_string());
        assert_eq!(owned_scope, Some("scope-123".to_string()));

        let scope_id_none: Option<&str> = None;
        let owned_none = scope_id_none.map(|s| s.to_string());
        assert_eq!(owned_none, None);
    }
}
